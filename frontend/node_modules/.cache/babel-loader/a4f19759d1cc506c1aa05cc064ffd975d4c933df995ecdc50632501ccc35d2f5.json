{"ast":null,"code":"/**\n * Manejo centralizado de errores de API\n */\n\nexport class APIErrorHandler {\n  /**\n   * Procesa errores de respuesta de la API\n   */\n  static async handleResponse(response) {\n    if (response.ok) {\n      return response.json();\n    }\n    let errorData;\n    try {\n      errorData = await response.json();\n    } catch {\n      // Si no se puede parsear el JSON, crear error genérico\n      errorData = {\n        message: `Error ${response.status}: ${response.statusText}`,\n        type: 'http_error',\n        details: {},\n        status: response.status\n      };\n    }\n\n    // Agregar código de estado si no está presente\n    if (!errorData.status) {\n      errorData.status = response.status;\n    }\n\n    // Procesar tipos específicos de error\n    throw this.createErrorFromAPIResponse(errorData);\n  }\n\n  /**\n   * Crea una instancia de error específica basada en la respuesta de la API\n   */\n  static createErrorFromAPIResponse(errorData) {\n    const error = new Error(errorData.message);\n    error.type = errorData.type;\n    error.details = errorData.details;\n    error.status = errorData.status;\n    return error;\n  }\n\n  /**\n   * Maneja errores de red y otros errores inesperados\n   */\n  static handleNetworkError(error) {\n    if (error.name === 'TypeError' && error.message.includes('fetch')) {\n      const networkError = new Error('Error de conexión. Verifica tu conexión a internet.');\n      networkError.type = 'network_error';\n      networkError.details = {};\n      return networkError;\n    }\n    if (error.name === 'AbortError') {\n      const timeoutError = new Error('La petición tardó demasiado tiempo. Inténtalo de nuevo.');\n      timeoutError.type = 'timeout_error';\n      timeoutError.details = {};\n      return timeoutError;\n    }\n\n    // Si ya es un error procesado, devolverlo tal como está\n    if (error.type) {\n      return error;\n    }\n\n    // Error genérico\n    const genericError = new Error('Ocurrió un error inesperado');\n    genericError.type = 'unknown_error';\n    genericError.details = {\n      originalError: error.message\n    };\n    return genericError;\n  }\n\n  /**\n   * Obtiene un mensaje de error amigable para el usuario\n   */\n  static getUserFriendlyMessage(error) {\n    const errorType = error.type;\n    const errorDetails = error.details || {};\n    switch (errorType) {\n      case 'validation_error':\n        if (errorDetails.validation_errors && Array.isArray(errorDetails.validation_errors)) {\n          var _errorDetails$validat;\n          return `Error de validación: ${((_errorDetails$validat = errorDetails.validation_errors[0]) === null || _errorDetails$validat === void 0 ? void 0 : _errorDetails$validat.msg) || error.message}`;\n        }\n        return `Datos inválidos: ${error.message}`;\n      case 'not_found_error':\n        return 'El recurso solicitado no fue encontrado';\n      case 'duplicate_error':\n        return 'Ya existe un recurso con esos datos';\n      case 'insufficient_stock_error':\n        if (errorDetails.insufficient_items) {\n          const items = errorDetails.insufficient_items;\n          const itemMessages = items.map(item => `${item.product_name}: disponible ${item.available}, solicitado ${item.requested}`);\n          return `Stock insuficiente:\\n${itemMessages.join('\\n')}`;\n        }\n        return 'Stock insuficiente para completar la operación';\n      case 'business_logic_error':\n        return `Error en la operación: ${error.message}`;\n      case 'authentication_error':\n        return 'Error de autenticación. Por favor, inicia sesión nuevamente';\n      case 'authorization_error':\n        return 'No tienes permisos para realizar esta acción';\n      case 'database_integrity_error':\n        return 'Error de integridad en los datos. Verifica la información';\n      case 'database_error':\n        return 'Error en la base de datos. Inténtalo más tarde';\n      case 'network_error':\n        return 'Error de conexión. Verifica tu conexión a internet';\n      case 'timeout_error':\n        return 'La operación tardó demasiado tiempo. Inténtalo de nuevo';\n      case 'internal_server_error':\n        return 'Error interno del servidor. Inténtalo más tarde';\n      default:\n        return error.message || 'Ocurrió un error inesperado';\n    }\n  }\n\n  /**\n   * Determina si un error es recuperable (el usuario puede intentar de nuevo)\n   */\n  static isRecoverableError(error) {\n    const errorType = error.type;\n    const status = error.status;\n\n    // Errores de red y timeout son recuperables\n    if (errorType === 'network_error' || errorType === 'timeout_error') {\n      return true;\n    }\n\n    // Errores 5xx del servidor son recuperables\n    if (status >= 500) {\n      return true;\n    }\n\n    // Errores 4xx generalmente no son recuperables (excepto 408, 429)\n    if (status === 408 || status === 429) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Determina si el error requiere reautenticación\n   */\n  static requiresReauth(error) {\n    const status = error.status;\n    const errorType = error.type;\n    return status === 401 || errorType === 'authentication_error';\n  }\n}\n\n/**\n * Wrapper para fetch que maneja errores automáticamente\n */\nexport async function apiFetch(url, options = {}) {\n  try {\n    // Agregar timeout por defecto\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 segundos\n\n    const response = await fetch(url, {\n      ...options,\n      signal: controller.signal,\n      credentials: 'include' // Incluir cookies por defecto\n    });\n    clearTimeout(timeoutId);\n    return await APIErrorHandler.handleResponse(response);\n  } catch (error) {\n    throw APIErrorHandler.handleNetworkError(error);\n  }\n}","map":{"version":3,"names":["APIErrorHandler","handleResponse","response","ok","json","errorData","message","status","statusText","type","details","createErrorFromAPIResponse","error","Error","handleNetworkError","name","includes","networkError","timeoutError","genericError","originalError","getUserFriendlyMessage","errorType","errorDetails","validation_errors","Array","isArray","_errorDetails$validat","msg","insufficient_items","items","itemMessages","map","item","product_name","available","requested","join","isRecoverableError","requiresReauth","apiFetch","url","options","controller","AbortController","timeoutId","setTimeout","abort","fetch","signal","credentials","clearTimeout"],"sources":["/Users/user/TuAppDeAccesorios/frontend/src/services/apiErrorHandler.ts"],"sourcesContent":["/**\n * Manejo centralizado de errores de API\n */\n\nexport interface APIError {\n  message: string;\n  type: string;\n  details: Record<string, any>;\n  status?: number;\n}\n\nexport class APIErrorHandler {\n  /**\n   * Procesa errores de respuesta de la API\n   */\n  static async handleResponse(response: Response): Promise<any> {\n    if (response.ok) {\n      return response.json();\n    }\n\n    let errorData: APIError;\n    \n    try {\n      errorData = await response.json();\n    } catch {\n      // Si no se puede parsear el JSON, crear error genérico\n      errorData = {\n        message: `Error ${response.status}: ${response.statusText}`,\n        type: 'http_error',\n        details: {},\n        status: response.status\n      };\n    }\n\n    // Agregar código de estado si no está presente\n    if (!errorData.status) {\n      errorData.status = response.status;\n    }\n\n    // Procesar tipos específicos de error\n    throw this.createErrorFromAPIResponse(errorData);\n  }\n\n  /**\n   * Crea una instancia de error específica basada en la respuesta de la API\n   */\n  private static createErrorFromAPIResponse(errorData: APIError): Error {\n    const error = new Error(errorData.message);\n    (error as any).type = errorData.type;\n    (error as any).details = errorData.details;\n    (error as any).status = errorData.status;\n    \n    return error;\n  }\n\n  /**\n   * Maneja errores de red y otros errores inesperados\n   */\n  static handleNetworkError(error: any): Error {\n    if (error.name === 'TypeError' && error.message.includes('fetch')) {\n      const networkError = new Error('Error de conexión. Verifica tu conexión a internet.');\n      (networkError as any).type = 'network_error';\n      (networkError as any).details = {};\n      return networkError;\n    }\n\n    if (error.name === 'AbortError') {\n      const timeoutError = new Error('La petición tardó demasiado tiempo. Inténtalo de nuevo.');\n      (timeoutError as any).type = 'timeout_error';\n      (timeoutError as any).details = {};\n      return timeoutError;\n    }\n\n    // Si ya es un error procesado, devolverlo tal como está\n    if ((error as any).type) {\n      return error;\n    }\n\n    // Error genérico\n    const genericError = new Error('Ocurrió un error inesperado');\n    (genericError as any).type = 'unknown_error';\n    (genericError as any).details = { originalError: error.message };\n    return genericError;\n  }\n\n  /**\n   * Obtiene un mensaje de error amigable para el usuario\n   */\n  static getUserFriendlyMessage(error: any): string {\n    const errorType = (error as any).type;\n    const errorDetails = (error as any).details || {};\n\n    switch (errorType) {\n      case 'validation_error':\n        if (errorDetails.validation_errors && Array.isArray(errorDetails.validation_errors)) {\n          return `Error de validación: ${errorDetails.validation_errors[0]?.msg || error.message}`;\n        }\n        return `Datos inválidos: ${error.message}`;\n\n      case 'not_found_error':\n        return 'El recurso solicitado no fue encontrado';\n\n      case 'duplicate_error':\n        return 'Ya existe un recurso con esos datos';\n\n      case 'insufficient_stock_error':\n        if (errorDetails.insufficient_items) {\n          const items = errorDetails.insufficient_items;\n          const itemMessages = items.map((item: any) => \n            `${item.product_name}: disponible ${item.available}, solicitado ${item.requested}`\n          );\n          return `Stock insuficiente:\\n${itemMessages.join('\\n')}`;\n        }\n        return 'Stock insuficiente para completar la operación';\n\n      case 'business_logic_error':\n        return `Error en la operación: ${error.message}`;\n\n      case 'authentication_error':\n        return 'Error de autenticación. Por favor, inicia sesión nuevamente';\n\n      case 'authorization_error':\n        return 'No tienes permisos para realizar esta acción';\n\n      case 'database_integrity_error':\n        return 'Error de integridad en los datos. Verifica la información';\n\n      case 'database_error':\n        return 'Error en la base de datos. Inténtalo más tarde';\n\n      case 'network_error':\n        return 'Error de conexión. Verifica tu conexión a internet';\n\n      case 'timeout_error':\n        return 'La operación tardó demasiado tiempo. Inténtalo de nuevo';\n\n      case 'internal_server_error':\n        return 'Error interno del servidor. Inténtalo más tarde';\n\n      default:\n        return error.message || 'Ocurrió un error inesperado';\n    }\n  }\n\n  /**\n   * Determina si un error es recuperable (el usuario puede intentar de nuevo)\n   */\n  static isRecoverableError(error: any): boolean {\n    const errorType = (error as any).type;\n    const status = (error as any).status;\n\n    // Errores de red y timeout son recuperables\n    if (errorType === 'network_error' || errorType === 'timeout_error') {\n      return true;\n    }\n\n    // Errores 5xx del servidor son recuperables\n    if (status >= 500) {\n      return true;\n    }\n\n    // Errores 4xx generalmente no son recuperables (excepto 408, 429)\n    if (status === 408 || status === 429) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Determina si el error requiere reautenticación\n   */\n  static requiresReauth(error: any): boolean {\n    const status = (error as any).status;\n    const errorType = (error as any).type;\n\n    return status === 401 || errorType === 'authentication_error';\n  }\n}\n\n/**\n * Wrapper para fetch que maneja errores automáticamente\n */\nexport async function apiFetch(url: string, options: RequestInit = {}): Promise<any> {\n  try {\n    // Agregar timeout por defecto\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 segundos\n\n    const response = await fetch(url, {\n      ...options,\n      signal: controller.signal,\n      credentials: 'include' // Incluir cookies por defecto\n    });\n\n    clearTimeout(timeoutId);\n    return await APIErrorHandler.handleResponse(response);\n\n  } catch (error) {\n    throw APIErrorHandler.handleNetworkError(error);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}