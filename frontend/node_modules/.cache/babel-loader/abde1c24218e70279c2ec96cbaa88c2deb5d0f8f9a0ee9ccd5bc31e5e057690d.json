{"ast":null,"code":"import _objectSpread from\"/Users/user/TuAppDeAccesorios/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";/**\n * Sistema de caché del lado del cliente\n */class ClientCacheManager{constructor(){let config=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this.cache=new Map();this.config=void 0;this.config=_objectSpread({defaultTTL:5*60*1000,// 5 minutos por defecto\nmaxSize:100,// Máximo 100 elementos\nstorageKey:'app_cache'},config);this.loadFromStorage();this.startCleanupTimer();}/**\n   * Almacena un elemento en el caché\n   */set(key,data,ttl){const expireTime=ttl||this.config.defaultTTL;const item={data,timestamp:Date.now(),ttl:expireTime};// Si el caché está lleno, eliminar el elemento más antiguo\nif(this.cache.size>=this.config.maxSize){this.evictOldest();}this.cache.set(key,item);this.saveToStorage();}/**\n   * Obtiene un elemento del caché\n   */get(key){const item=this.cache.get(key);if(!item){return null;}// Verificar si el elemento ha expirado\nif(this.isExpired(item)){this.cache.delete(key);this.saveToStorage();return null;}return item.data;}/**\n   * Verifica si un elemento existe en el caché y no ha expirado\n   */has(key){const item=this.cache.get(key);return item?!this.isExpired(item):false;}/**\n   * Elimina un elemento del caché\n   */delete(key){const result=this.cache.delete(key);if(result){this.saveToStorage();}return result;}/**\n   * Elimina elementos que coincidan con un patrón\n   */deletePattern(pattern){const regex=new RegExp(pattern);let deletedCount=0;for(const key of this.cache.keys()){if(regex.test(key)){this.cache.delete(key);deletedCount++;}}if(deletedCount>0){this.saveToStorage();}return deletedCount;}/**\n   * Limpia todo el caché\n   */clear(){this.cache.clear();this.saveToStorage();}/**\n   * Obtiene estadísticas del caché\n   */getStats(){// Estas estadísticas se podrían mejorar con un tracking más detallado\nreturn{size:this.cache.size,maxSize:this.config.maxSize,hitRate:0,// TODO: Implementar tracking de hits/misses\ntotalRequests:0,hits:0,misses:0};}/**\n   * Verifica si un elemento ha expirado\n   */isExpired(item){return Date.now()-item.timestamp>item.ttl;}/**\n   * Elimina el elemento más antiguo del caché\n   */evictOldest(){let oldestKey=null;let oldestTimestamp=Date.now();for(const[key,item]of this.cache.entries()){if(item.timestamp<oldestTimestamp){oldestTimestamp=item.timestamp;oldestKey=key;}}if(oldestKey){this.cache.delete(oldestKey);}}/**\n   * Limpia elementos expirados\n   */cleanup(){const expiredKeys=[];for(const[key,item]of this.cache.entries()){if(this.isExpired(item)){expiredKeys.push(key);}}if(expiredKeys.length>0){for(const key of expiredKeys){this.cache.delete(key);}this.saveToStorage();}}/**\n   * Inicia el timer de limpieza periódica\n   */startCleanupTimer(){setInterval(()=>{this.cleanup();},60000);// Limpiar cada minuto\n}/**\n   * Guarda el caché en localStorage\n   */saveToStorage(){try{const serializedCache=Array.from(this.cache.entries());localStorage.setItem(this.config.storageKey,JSON.stringify(serializedCache));}catch(error){console.warn('Error saving cache to localStorage:',error);}}/**\n   * Carga el caché desde localStorage\n   */loadFromStorage(){try{const stored=localStorage.getItem(this.config.storageKey);if(stored){const parsed=JSON.parse(stored);this.cache=new Map(parsed);// Limpiar elementos expirados al cargar\nthis.cleanup();}}catch(error){console.warn('Error loading cache from localStorage:',error);this.cache.clear();}}}// Configuraciones específicas para diferentes tipos de datos\nexport const CacheSettings={PRODUCTS:{TTL:2*60*1000,// 2 minutos\nPREFIX:'products'},PRODUCT_SEARCH:{TTL:30*1000,// 30 segundos\nPREFIX:'search'},USER_SESSION:{TTL:15*60*1000,// 15 minutos\nPREFIX:'session'},STATIC_DATA:{TTL:30*60*1000,// 30 minutos\nPREFIX:'static'}};// Instancia global del caché\nexport const clientCache=new ClientCacheManager({defaultTTL:5*60*1000,maxSize:200,storageKey:'tuapp_cache'});// Funciones de utilidad para caché específico\nexport function cacheProductsList(products){let skip=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;let limit=arguments.length>2&&arguments[2]!==undefined?arguments[2]:20;const key=\"\".concat(CacheSettings.PRODUCTS.PREFIX,\":list:\").concat(skip,\":\").concat(limit);clientCache.set(key,products,CacheSettings.PRODUCTS.TTL);}export function getCachedProductsList(){let skip=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;let limit=arguments.length>1&&arguments[1]!==undefined?arguments[1]:20;const key=\"\".concat(CacheSettings.PRODUCTS.PREFIX,\":list:\").concat(skip,\":\").concat(limit);return clientCache.get(key);}export function cacheProductSearch(query,results){const key=\"\".concat(CacheSettings.PRODUCT_SEARCH.PREFIX,\":\").concat(query);clientCache.set(key,results,CacheSettings.PRODUCT_SEARCH.TTL);}export function getCachedProductSearch(query){const key=\"\".concat(CacheSettings.PRODUCT_SEARCH.PREFIX,\":\").concat(query);return clientCache.get(key);}export function invalidateProductsCache(){clientCache.deletePattern(\"\".concat(CacheSettings.PRODUCTS.PREFIX,\":.*\"));clientCache.deletePattern(\"\".concat(CacheSettings.PRODUCT_SEARCH.PREFIX,\":.*\"));}export function cacheUserSession(userId,sessionData){const key=\"\".concat(CacheSettings.USER_SESSION.PREFIX,\":\").concat(userId);clientCache.set(key,sessionData,CacheSettings.USER_SESSION.TTL);}export function getCachedUserSession(userId){const key=\"\".concat(CacheSettings.USER_SESSION.PREFIX,\":\").concat(userId);return clientCache.get(key);}// Hook para usar caché en React\nexport function useClientCache(){const setCache=(key,data,ttl)=>{clientCache.set(key,data,ttl);};const getCache=key=>{return clientCache.get(key);};const hasCache=key=>{return clientCache.has(key);};const deleteCache=key=>{return clientCache.delete(key);};const clearCache=()=>{clientCache.clear();};const getStats=()=>{return clientCache.getStats();};return{setCache,getCache,hasCache,deleteCache,clearCache,getStats};}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}