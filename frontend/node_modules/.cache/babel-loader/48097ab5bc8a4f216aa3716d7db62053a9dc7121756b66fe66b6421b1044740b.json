{"ast":null,"code":"// ==================================================================\n// AUTH MIDDLEWARE - REEMPLAZO DEL useTokenRefresh HOOK\n// ==================================================================\n\nimport { createListenerMiddleware } from '@reduxjs/toolkit';\nimport { refreshAuthToken, logout, selectIsAuthenticated } from '../slices/authSlice';\nexport const authMiddleware = createListenerMiddleware();\n\n// Intervalo para refresh automático del token (14 minutos)\nconst TOKEN_REFRESH_INTERVAL = 14 * 60 * 1000; // 14 minutos en milisegundos\n\nlet refreshInterval = null;\n\n// Listener para iniciar/detener el refresh automático\nauthMiddleware.startListening({\n  predicate: (_, currentState, previousState) => {\n    const current = currentState;\n    const previous = previousState;\n\n    // Verificar si cambió el estado de autenticación\n    return current.auth.isAuthenticated !== previous.auth.isAuthenticated;\n  },\n  effect: async (_, listenerApi) => {\n    const state = listenerApi.getState();\n    const isAuthenticated = selectIsAuthenticated(state);\n    if (isAuthenticated) {\n      // Iniciar refresh automático\n      startTokenRefreshInterval(listenerApi);\n    } else {\n      // Detener refresh automático\n      stopTokenRefreshInterval();\n    }\n  }\n});\n\n// Listener para manejar errores de autenticación\nauthMiddleware.startListening({\n  predicate: action => {\n    var _action$payload;\n    // Detectar errores 401 Unauthorized\n    return action.type.endsWith('/rejected') && ((_action$payload = action.payload) === null || _action$payload === void 0 ? void 0 : _action$payload.status) === 401;\n  },\n  effect: async (_, listenerApi) => {\n    const state = listenerApi.getState();\n    const isAuthenticated = selectIsAuthenticated(state);\n    if (isAuthenticated) {\n      // Intentar refrescar token\n      const refreshResult = await listenerApi.dispatch(refreshAuthToken());\n      if (refreshAuthToken.rejected.match(refreshResult)) {\n        // Si el refresh falla, hacer logout\n        await listenerApi.dispatch(logout());\n      }\n    }\n  }\n});\n\n// Función para iniciar el intervalo de refresh\nfunction startTokenRefreshInterval(listenerApi) {\n  // Limpiar intervalo existente\n  if (refreshInterval) {\n    clearInterval(refreshInterval);\n  }\n\n  // Crear nuevo intervalo\n  refreshInterval = setInterval(async () => {\n    const state = listenerApi.getState();\n    const isAuthenticated = selectIsAuthenticated(state);\n    if (isAuthenticated) {\n      try {\n        const refreshResult = await listenerApi.dispatch(refreshAuthToken());\n        if (refreshAuthToken.rejected.match(refreshResult)) {\n          console.warn('Token refresh failed, logging out');\n          await listenerApi.dispatch(logout());\n        }\n      } catch (error) {\n        console.error('Error during token refresh:', error);\n        await listenerApi.dispatch(logout());\n      }\n    }\n  }, TOKEN_REFRESH_INTERVAL);\n}\n\n// Función para detener el intervalo de refresh\nfunction stopTokenRefreshInterval() {\n  if (refreshInterval) {\n    clearInterval(refreshInterval);\n    refreshInterval = null;\n  }\n}\n\n// Limpiar intervalo cuando la aplicación se cierre\nif (typeof window !== 'undefined') {\n  window.addEventListener('beforeunload', () => {\n    stopTokenRefreshInterval();\n  });\n}\nexport default authMiddleware;","map":{"version":3,"names":["createListenerMiddleware","refreshAuthToken","logout","selectIsAuthenticated","authMiddleware","TOKEN_REFRESH_INTERVAL","refreshInterval","startListening","predicate","_","currentState","previousState","current","previous","auth","isAuthenticated","effect","listenerApi","state","getState","startTokenRefreshInterval","stopTokenRefreshInterval","action","_action$payload","type","endsWith","payload","status","refreshResult","dispatch","rejected","match","clearInterval","setInterval","console","warn","error","window","addEventListener"],"sources":["/Users/user/TuAppDeAccesorios/frontend/src/store/middleware/authMiddleware.ts"],"sourcesContent":["// ==================================================================\n// AUTH MIDDLEWARE - REEMPLAZO DEL useTokenRefresh HOOK\n// ==================================================================\n\nimport { createListenerMiddleware } from '@reduxjs/toolkit';\nimport { refreshAuthToken, logout, selectIsAuthenticated } from '../slices/authSlice';\nimport type { RootState } from '../index';\n\nexport const authMiddleware = createListenerMiddleware();\n\n// Intervalo para refresh automático del token (14 minutos)\nconst TOKEN_REFRESH_INTERVAL = 14 * 60 * 1000; // 14 minutos en milisegundos\n\nlet refreshInterval: ReturnType<typeof setInterval> | null = null;\n\n// Listener para iniciar/detener el refresh automático\nauthMiddleware.startListening({\n  predicate: (_, currentState, previousState) => {\n    const current = currentState as RootState;\n    const previous = previousState as RootState;\n    \n    // Verificar si cambió el estado de autenticación\n    return current.auth.isAuthenticated !== previous.auth.isAuthenticated;\n  },\n  effect: async (_, listenerApi) => {\n    const state = listenerApi.getState() as RootState;\n    const isAuthenticated = selectIsAuthenticated(state);\n    \n    if (isAuthenticated) {\n      // Iniciar refresh automático\n      startTokenRefreshInterval(listenerApi);\n    } else {\n      // Detener refresh automático\n      stopTokenRefreshInterval();\n    }\n  },\n});\n\n// Listener para manejar errores de autenticación\nauthMiddleware.startListening({\n  predicate: (action) => {\n    // Detectar errores 401 Unauthorized\n    return action.type.endsWith('/rejected') && \n           (action.payload as any)?.status === 401;\n  },\n  effect: async (_, listenerApi) => {\n    const state = listenerApi.getState() as RootState;\n    const isAuthenticated = selectIsAuthenticated(state);\n    \n    if (isAuthenticated) {\n      // Intentar refrescar token\n      const refreshResult = await listenerApi.dispatch(refreshAuthToken());\n      \n      if (refreshAuthToken.rejected.match(refreshResult)) {\n        // Si el refresh falla, hacer logout\n        await listenerApi.dispatch(logout());\n      }\n    }\n  },\n});\n\n// Función para iniciar el intervalo de refresh\nfunction startTokenRefreshInterval(listenerApi: any) {\n  // Limpiar intervalo existente\n  if (refreshInterval) {\n    clearInterval(refreshInterval);\n  }\n  \n  // Crear nuevo intervalo\n  refreshInterval = setInterval(async () => {\n    const state = listenerApi.getState() as RootState;\n    const isAuthenticated = selectIsAuthenticated(state);\n    \n    if (isAuthenticated) {\n      try {\n        const refreshResult = await listenerApi.dispatch(refreshAuthToken());\n        \n        if (refreshAuthToken.rejected.match(refreshResult)) {\n          console.warn('Token refresh failed, logging out');\n          await listenerApi.dispatch(logout());\n        }\n      } catch (error) {\n        console.error('Error during token refresh:', error);\n        await listenerApi.dispatch(logout());\n      }\n    }\n  }, TOKEN_REFRESH_INTERVAL);\n}\n\n// Función para detener el intervalo de refresh\nfunction stopTokenRefreshInterval() {\n  if (refreshInterval) {\n    clearInterval(refreshInterval);\n    refreshInterval = null;\n  }\n}\n\n// Limpiar intervalo cuando la aplicación se cierre\nif (typeof window !== 'undefined') {\n  window.addEventListener('beforeunload', () => {\n    stopTokenRefreshInterval();\n  });\n}\n\nexport default authMiddleware;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}