{"ast":null,"code":"// ==================================================================\n// AUTH SLICE - REEMPLAZO DEL CONTEXT API\n// ==================================================================\nimport{createSlice,createAsyncThunk}from'@reduxjs/toolkit';import{authApi}from'../../services/api';const initialState={isAuthenticated:false,userRole:null,isInitialized:false,isLoading:false,error:null,token:null,refreshToken:null};// Async thunks\nexport const login=createAsyncThunk('auth/login',async(credentials,_ref)=>{let{rejectWithValue}=_ref;try{const response=await authApi.login(credentials);// Almacenar tokens en localStorage\nlocalStorage.setItem('access_token',response.data.access_token);localStorage.setItem('refresh_token',response.data.refresh_token);localStorage.setItem('user_role',response.data.user_role);return{token:response.data.access_token,refreshToken:response.data.refresh_token,userRole:response.data.user_role};}catch(error){var _error$response,_error$response$data;return rejectWithValue(((_error$response=error.response)===null||_error$response===void 0?void 0:(_error$response$data=_error$response.data)===null||_error$response$data===void 0?void 0:_error$response$data.detail)||'Error en el login');}});export const refreshAuthToken=createAsyncThunk('auth/refreshToken',async(_,_ref2)=>{let{rejectWithValue}=_ref2;try{const refreshToken=localStorage.getItem('refresh_token');if(!refreshToken){throw new Error('No refresh token available');}const response=await authApi.refreshToken(refreshToken);// Actualizar tokens\nlocalStorage.setItem('access_token',response.data.access_token);localStorage.setItem('refresh_token',response.data.refresh_token);return{token:response.data.access_token,refreshToken:response.data.refresh_token};}catch(error){var _error$response2,_error$response2$data;// Limpiar tokens inválidos\nlocalStorage.removeItem('access_token');localStorage.removeItem('refresh_token');localStorage.removeItem('user_role');return rejectWithValue(((_error$response2=error.response)===null||_error$response2===void 0?void 0:(_error$response2$data=_error$response2.data)===null||_error$response2$data===void 0?void 0:_error$response2$data.detail)||'Error al refrescar token');}});export const checkAuthStatus=createAsyncThunk('auth/checkStatus',async(_,_ref3)=>{let{dispatch,rejectWithValue}=_ref3;try{const token=localStorage.getItem('access_token');const userRole=localStorage.getItem('user_role');if(!token){throw new Error('No token found');}// Verificar si el token es válido\nconst response=await authApi.verifyToken(token);return{token,userRole,isValid:response.data.valid};}catch(error){// Si el token no es válido, intentar refrescar\nconst refreshResult=await dispatch(refreshAuthToken());if(refreshAuthToken.fulfilled.match(refreshResult)){return{token:refreshResult.payload.token,userRole:localStorage.getItem('user_role'),isValid:true};}return rejectWithValue('Authentication verification failed');}});export const logout=createAsyncThunk('auth/logout',async(_,_ref4)=>{let{rejectWithValue}=_ref4;try{const token=localStorage.getItem('access_token');if(token){await authApi.logout(token);}}catch(error){// Ignorar errores de logout en el servidor\nconsole.warn('Logout server error:',error);}finally{// Siempre limpiar tokens locales\nlocalStorage.removeItem('access_token');localStorage.removeItem('refresh_token');localStorage.removeItem('user_role');}});// Slice\nconst authSlice=createSlice({name:'auth',initialState,reducers:{clearError:state=>{state.error=null;},resetAuth:state=>{Object.assign(state,initialState);}},extraReducers:builder=>{builder// Login\n.addCase(login.pending,state=>{state.isLoading=true;state.error=null;}).addCase(login.fulfilled,(state,action)=>{state.isLoading=false;state.isAuthenticated=true;state.token=action.payload.token;state.refreshToken=action.payload.refreshToken;state.userRole=action.payload.userRole;state.error=null;}).addCase(login.rejected,(state,action)=>{state.isLoading=false;state.isAuthenticated=false;state.token=null;state.refreshToken=null;state.userRole=null;state.error=action.payload;})// Refresh token\n.addCase(refreshAuthToken.pending,state=>{state.isLoading=true;}).addCase(refreshAuthToken.fulfilled,(state,action)=>{state.isLoading=false;state.token=action.payload.token;state.refreshToken=action.payload.refreshToken;state.error=null;}).addCase(refreshAuthToken.rejected,(state,action)=>{state.isLoading=false;state.isAuthenticated=false;state.token=null;state.refreshToken=null;state.userRole=null;state.error=action.payload;})// Check auth status\n.addCase(checkAuthStatus.pending,state=>{state.isLoading=true;state.isInitialized=false;}).addCase(checkAuthStatus.fulfilled,(state,action)=>{state.isLoading=false;state.isInitialized=true;state.isAuthenticated=action.payload.isValid;state.token=action.payload.token;state.userRole=action.payload.userRole;state.error=null;}).addCase(checkAuthStatus.rejected,(state,action)=>{state.isLoading=false;state.isInitialized=true;state.isAuthenticated=false;state.token=null;state.refreshToken=null;state.userRole=null;state.error=action.payload;})// Logout\n.addCase(logout.pending,state=>{state.isLoading=true;}).addCase(logout.fulfilled,state=>{Object.assign(state,initialState,{isInitialized:true});}).addCase(logout.rejected,state=>{// Siempre limpiar el estado incluso si el logout falla\nObject.assign(state,initialState,{isInitialized:true});});}});export const{clearError,resetAuth}=authSlice.actions;export default authSlice.reducer;// Selectores\nexport const selectAuth=state=>state.auth;export const selectIsAuthenticated=state=>state.auth.isAuthenticated;export const selectUserRole=state=>state.auth.userRole;export const selectIsInitialized=state=>state.auth.isInitialized;export const selectIsLoading=state=>state.auth.isLoading;export const selectAuthError=state=>state.auth.error;export const selectToken=state=>state.auth.token;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}