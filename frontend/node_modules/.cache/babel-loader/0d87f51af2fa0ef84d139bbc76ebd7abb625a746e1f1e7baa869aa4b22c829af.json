{"ast":null,"code":"/**\n * Sistema de caché del lado del cliente\n */\n\nclass ClientCacheManager {\n  constructor(config = {}) {\n    this.cache = new Map();\n    this.config = void 0;\n    this.config = {\n      defaultTTL: 5 * 60 * 1000,\n      // 5 minutos por defecto\n      maxSize: 100,\n      // Máximo 100 elementos\n      storageKey: 'app_cache',\n      ...config\n    };\n    this.loadFromStorage();\n    this.startCleanupTimer();\n  }\n\n  /**\n   * Almacena un elemento en el caché\n   */\n  set(key, data, ttl) {\n    const expireTime = ttl || this.config.defaultTTL;\n    const item = {\n      data,\n      timestamp: Date.now(),\n      ttl: expireTime\n    };\n\n    // Si el caché está lleno, eliminar el elemento más antiguo\n    if (this.cache.size >= this.config.maxSize) {\n      this.evictOldest();\n    }\n    this.cache.set(key, item);\n    this.saveToStorage();\n  }\n\n  /**\n   * Obtiene un elemento del caché\n   */\n  get(key) {\n    const item = this.cache.get(key);\n    if (!item) {\n      return null;\n    }\n\n    // Verificar si el elemento ha expirado\n    if (this.isExpired(item)) {\n      this.cache.delete(key);\n      this.saveToStorage();\n      return null;\n    }\n    return item.data;\n  }\n\n  /**\n   * Verifica si un elemento existe en el caché y no ha expirado\n   */\n  has(key) {\n    const item = this.cache.get(key);\n    return item ? !this.isExpired(item) : false;\n  }\n\n  /**\n   * Elimina un elemento del caché\n   */\n  delete(key) {\n    const result = this.cache.delete(key);\n    if (result) {\n      this.saveToStorage();\n    }\n    return result;\n  }\n\n  /**\n   * Elimina elementos que coincidan con un patrón\n   */\n  deletePattern(pattern) {\n    const regex = new RegExp(pattern);\n    let deletedCount = 0;\n    for (const key of this.cache.keys()) {\n      if (regex.test(key)) {\n        this.cache.delete(key);\n        deletedCount++;\n      }\n    }\n    if (deletedCount > 0) {\n      this.saveToStorage();\n    }\n    return deletedCount;\n  }\n\n  /**\n   * Limpia todo el caché\n   */\n  clear() {\n    this.cache.clear();\n    this.saveToStorage();\n  }\n\n  /**\n   * Obtiene estadísticas del caché\n   */\n  getStats() {\n    // Estas estadísticas se podrían mejorar con un tracking más detallado\n    return {\n      size: this.cache.size,\n      maxSize: this.config.maxSize,\n      hitRate: 0,\n      // TODO: Implementar tracking de hits/misses\n      totalRequests: 0,\n      hits: 0,\n      misses: 0\n    };\n  }\n\n  /**\n   * Verifica si un elemento ha expirado\n   */\n  isExpired(item) {\n    return Date.now() - item.timestamp > item.ttl;\n  }\n\n  /**\n   * Elimina el elemento más antiguo del caché\n   */\n  evictOldest() {\n    let oldestKey = null;\n    let oldestTimestamp = Date.now();\n    for (const [key, item] of this.cache.entries()) {\n      if (item.timestamp < oldestTimestamp) {\n        oldestTimestamp = item.timestamp;\n        oldestKey = key;\n      }\n    }\n    if (oldestKey) {\n      this.cache.delete(oldestKey);\n    }\n  }\n\n  /**\n   * Limpia elementos expirados\n   */\n  cleanup() {\n    const expiredKeys = [];\n    for (const [key, item] of this.cache.entries()) {\n      if (this.isExpired(item)) {\n        expiredKeys.push(key);\n      }\n    }\n    if (expiredKeys.length > 0) {\n      for (const key of expiredKeys) {\n        this.cache.delete(key);\n      }\n      this.saveToStorage();\n    }\n  }\n\n  /**\n   * Inicia el timer de limpieza periódica\n   */\n  startCleanupTimer() {\n    setInterval(() => {\n      this.cleanup();\n    }, 60000); // Limpiar cada minuto\n  }\n\n  /**\n   * Guarda el caché en localStorage\n   */\n  saveToStorage() {\n    try {\n      const serializedCache = Array.from(this.cache.entries());\n      localStorage.setItem(this.config.storageKey, JSON.stringify(serializedCache));\n    } catch (error) {\n      console.warn('Error saving cache to localStorage:', error);\n    }\n  }\n\n  /**\n   * Carga el caché desde localStorage\n   */\n  loadFromStorage() {\n    try {\n      const stored = localStorage.getItem(this.config.storageKey);\n      if (stored) {\n        const parsed = JSON.parse(stored);\n        this.cache = new Map(parsed);\n        // Limpiar elementos expirados al cargar\n        this.cleanup();\n      }\n    } catch (error) {\n      console.warn('Error loading cache from localStorage:', error);\n      this.cache.clear();\n    }\n  }\n}\n\n// Configuraciones específicas para diferentes tipos de datos\nexport const CacheSettings = {\n  PRODUCTS: {\n    TTL: 2 * 60 * 1000,\n    // 2 minutos\n    PREFIX: 'products'\n  },\n  PRODUCT_SEARCH: {\n    TTL: 30 * 1000,\n    // 30 segundos\n    PREFIX: 'search'\n  },\n  USER_SESSION: {\n    TTL: 15 * 60 * 1000,\n    // 15 minutos\n    PREFIX: 'session'\n  },\n  STATIC_DATA: {\n    TTL: 30 * 60 * 1000,\n    // 30 minutos\n    PREFIX: 'static'\n  }\n};\n\n// Instancia global del caché\nexport const clientCache = new ClientCacheManager({\n  defaultTTL: 5 * 60 * 1000,\n  maxSize: 200,\n  storageKey: 'tuapp_cache'\n});\n\n// Funciones de utilidad para caché específico\n\nexport function cacheProductsList(products, skip = 0, limit = 20) {\n  const key = `${CacheSettings.PRODUCTS.PREFIX}:list:${skip}:${limit}`;\n  clientCache.set(key, products, CacheSettings.PRODUCTS.TTL);\n}\nexport function getCachedProductsList(skip = 0, limit = 20) {\n  const key = `${CacheSettings.PRODUCTS.PREFIX}:list:${skip}:${limit}`;\n  return clientCache.get(key);\n}\nexport function cacheProductSearch(query, results) {\n  const key = `${CacheSettings.PRODUCT_SEARCH.PREFIX}:${query}`;\n  clientCache.set(key, results, CacheSettings.PRODUCT_SEARCH.TTL);\n}\nexport function getCachedProductSearch(query) {\n  const key = `${CacheSettings.PRODUCT_SEARCH.PREFIX}:${query}`;\n  return clientCache.get(key);\n}\nexport function invalidateProductsCache() {\n  clientCache.deletePattern(`${CacheSettings.PRODUCTS.PREFIX}:.*`);\n  clientCache.deletePattern(`${CacheSettings.PRODUCT_SEARCH.PREFIX}:.*`);\n}\nexport function cacheUserSession(userId, sessionData) {\n  const key = `${CacheSettings.USER_SESSION.PREFIX}:${userId}`;\n  clientCache.set(key, sessionData, CacheSettings.USER_SESSION.TTL);\n}\nexport function getCachedUserSession(userId) {\n  const key = `${CacheSettings.USER_SESSION.PREFIX}:${userId}`;\n  return clientCache.get(key);\n}\n\n// Hook para usar caché en React\nexport function useClientCache() {\n  const setCache = (key, data, ttl) => {\n    clientCache.set(key, data, ttl);\n  };\n  const getCache = key => {\n    return clientCache.get(key);\n  };\n  const hasCache = key => {\n    return clientCache.has(key);\n  };\n  const deleteCache = key => {\n    return clientCache.delete(key);\n  };\n  const clearCache = () => {\n    clientCache.clear();\n  };\n  const getStats = () => {\n    return clientCache.getStats();\n  };\n  return {\n    setCache,\n    getCache,\n    hasCache,\n    deleteCache,\n    clearCache,\n    getStats\n  };\n}","map":{"version":3,"names":["ClientCacheManager","constructor","config","cache","Map","defaultTTL","maxSize","storageKey","loadFromStorage","startCleanupTimer","set","key","data","ttl","expireTime","item","timestamp","Date","now","size","evictOldest","saveToStorage","get","isExpired","delete","has","result","deletePattern","pattern","regex","RegExp","deletedCount","keys","test","clear","getStats","hitRate","totalRequests","hits","misses","oldestKey","oldestTimestamp","entries","cleanup","expiredKeys","push","length","setInterval","serializedCache","Array","from","localStorage","setItem","JSON","stringify","error","console","warn","stored","getItem","parsed","parse","CacheSettings","PRODUCTS","TTL","PREFIX","PRODUCT_SEARCH","USER_SESSION","STATIC_DATA","clientCache","cacheProductsList","products","skip","limit","getCachedProductsList","cacheProductSearch","query","results","getCachedProductSearch","invalidateProductsCache","cacheUserSession","userId","sessionData","getCachedUserSession","useClientCache","setCache","getCache","hasCache","deleteCache","clearCache"],"sources":["/Users/user/TuAppDeAccesorios/frontend/src/services/clientCache.ts"],"sourcesContent":["/**\n * Sistema de caché del lado del cliente\n */\n\ninterface CacheItem {\n  data: any;\n  timestamp: number;\n  ttl: number; // Time to live in milliseconds\n}\n\ninterface CacheConfig {\n  defaultTTL: number;\n  maxSize: number;\n  storageKey: string;\n}\n\nclass ClientCacheManager {\n  private cache: Map<string, CacheItem> = new Map();\n  private config: CacheConfig;\n\n  constructor(config: Partial<CacheConfig> = {}) {\n    this.config = {\n      defaultTTL: 5 * 60 * 1000, // 5 minutos por defecto\n      maxSize: 100, // Máximo 100 elementos\n      storageKey: 'app_cache',\n      ...config\n    };\n\n    this.loadFromStorage();\n    this.startCleanupTimer();\n  }\n\n  /**\n   * Almacena un elemento en el caché\n   */\n  set(key: string, data: any, ttl?: number): void {\n    const expireTime = ttl || this.config.defaultTTL;\n    const item: CacheItem = {\n      data,\n      timestamp: Date.now(),\n      ttl: expireTime\n    };\n\n    // Si el caché está lleno, eliminar el elemento más antiguo\n    if (this.cache.size >= this.config.maxSize) {\n      this.evictOldest();\n    }\n\n    this.cache.set(key, item);\n    this.saveToStorage();\n  }\n\n  /**\n   * Obtiene un elemento del caché\n   */\n  get(key: string): any | null {\n    const item = this.cache.get(key);\n    \n    if (!item) {\n      return null;\n    }\n\n    // Verificar si el elemento ha expirado\n    if (this.isExpired(item)) {\n      this.cache.delete(key);\n      this.saveToStorage();\n      return null;\n    }\n\n    return item.data;\n  }\n\n  /**\n   * Verifica si un elemento existe en el caché y no ha expirado\n   */\n  has(key: string): boolean {\n    const item = this.cache.get(key);\n    return item ? !this.isExpired(item) : false;\n  }\n\n  /**\n   * Elimina un elemento del caché\n   */\n  delete(key: string): boolean {\n    const result = this.cache.delete(key);\n    if (result) {\n      this.saveToStorage();\n    }\n    return result;\n  }\n\n  /**\n   * Elimina elementos que coincidan con un patrón\n   */\n  deletePattern(pattern: string): number {\n    const regex = new RegExp(pattern);\n    let deletedCount = 0;\n\n    for (const key of this.cache.keys()) {\n      if (regex.test(key)) {\n        this.cache.delete(key);\n        deletedCount++;\n      }\n    }\n\n    if (deletedCount > 0) {\n      this.saveToStorage();\n    }\n\n    return deletedCount;\n  }\n\n  /**\n   * Limpia todo el caché\n   */\n  clear(): void {\n    this.cache.clear();\n    this.saveToStorage();\n  }\n\n  /**\n   * Obtiene estadísticas del caché\n   */\n  getStats(): {\n    size: number;\n    maxSize: number;\n    hitRate: number;\n    totalRequests: number;\n    hits: number;\n    misses: number;\n  } {\n    // Estas estadísticas se podrían mejorar con un tracking más detallado\n    return {\n      size: this.cache.size,\n      maxSize: this.config.maxSize,\n      hitRate: 0, // TODO: Implementar tracking de hits/misses\n      totalRequests: 0,\n      hits: 0,\n      misses: 0\n    };\n  }\n\n  /**\n   * Verifica si un elemento ha expirado\n   */\n  private isExpired(item: CacheItem): boolean {\n    return Date.now() - item.timestamp > item.ttl;\n  }\n\n  /**\n   * Elimina el elemento más antiguo del caché\n   */\n  private evictOldest(): void {\n    let oldestKey: string | null = null;\n    let oldestTimestamp = Date.now();\n\n    for (const [key, item] of this.cache.entries()) {\n      if (item.timestamp < oldestTimestamp) {\n        oldestTimestamp = item.timestamp;\n        oldestKey = key;\n      }\n    }\n\n    if (oldestKey) {\n      this.cache.delete(oldestKey);\n    }\n  }\n\n  /**\n   * Limpia elementos expirados\n   */\n  private cleanup(): void {\n    const expiredKeys: string[] = [];\n\n    for (const [key, item] of this.cache.entries()) {\n      if (this.isExpired(item)) {\n        expiredKeys.push(key);\n      }\n    }\n\n    if (expiredKeys.length > 0) {\n      for (const key of expiredKeys) {\n        this.cache.delete(key);\n      }\n      this.saveToStorage();\n    }\n  }\n\n  /**\n   * Inicia el timer de limpieza periódica\n   */\n  private startCleanupTimer(): void {\n    setInterval(() => {\n      this.cleanup();\n    }, 60000); // Limpiar cada minuto\n  }\n\n  /**\n   * Guarda el caché en localStorage\n   */\n  private saveToStorage(): void {\n    try {\n      const serializedCache = Array.from(this.cache.entries());\n      localStorage.setItem(this.config.storageKey, JSON.stringify(serializedCache));\n    } catch (error) {\n      console.warn('Error saving cache to localStorage:', error);\n    }\n  }\n\n  /**\n   * Carga el caché desde localStorage\n   */\n  private loadFromStorage(): void {\n    try {\n      const stored = localStorage.getItem(this.config.storageKey);\n      if (stored) {\n        const parsed = JSON.parse(stored);\n        this.cache = new Map(parsed);\n        // Limpiar elementos expirados al cargar\n        this.cleanup();\n      }\n    } catch (error) {\n      console.warn('Error loading cache from localStorage:', error);\n      this.cache.clear();\n    }\n  }\n}\n\n// Configuraciones específicas para diferentes tipos de datos\nexport const CacheSettings = {\n  PRODUCTS: {\n    TTL: 2 * 60 * 1000, // 2 minutos\n    PREFIX: 'products'\n  },\n  PRODUCT_SEARCH: {\n    TTL: 30 * 1000, // 30 segundos\n    PREFIX: 'search'\n  },\n  USER_SESSION: {\n    TTL: 15 * 60 * 1000, // 15 minutos\n    PREFIX: 'session'\n  },\n  STATIC_DATA: {\n    TTL: 30 * 60 * 1000, // 30 minutos\n    PREFIX: 'static'\n  }\n};\n\n// Instancia global del caché\nexport const clientCache = new ClientCacheManager({\n  defaultTTL: 5 * 60 * 1000,\n  maxSize: 200,\n  storageKey: 'tuapp_cache'\n});\n\n// Funciones de utilidad para caché específico\n\nexport function cacheProductsList(products: any[], skip: number = 0, limit: number = 20): void {\n  const key = `${CacheSettings.PRODUCTS.PREFIX}:list:${skip}:${limit}`;\n  clientCache.set(key, products, CacheSettings.PRODUCTS.TTL);\n}\n\nexport function getCachedProductsList(skip: number = 0, limit: number = 20): any[] | null {\n  const key = `${CacheSettings.PRODUCTS.PREFIX}:list:${skip}:${limit}`;\n  return clientCache.get(key);\n}\n\nexport function cacheProductSearch(query: string, results: any[]): void {\n  const key = `${CacheSettings.PRODUCT_SEARCH.PREFIX}:${query}`;\n  clientCache.set(key, results, CacheSettings.PRODUCT_SEARCH.TTL);\n}\n\nexport function getCachedProductSearch(query: string): any[] | null {\n  const key = `${CacheSettings.PRODUCT_SEARCH.PREFIX}:${query}`;\n  return clientCache.get(key);\n}\n\nexport function invalidateProductsCache(): void {\n  clientCache.deletePattern(`${CacheSettings.PRODUCTS.PREFIX}:.*`);\n  clientCache.deletePattern(`${CacheSettings.PRODUCT_SEARCH.PREFIX}:.*`);\n}\n\nexport function cacheUserSession(userId: number, sessionData: any): void {\n  const key = `${CacheSettings.USER_SESSION.PREFIX}:${userId}`;\n  clientCache.set(key, sessionData, CacheSettings.USER_SESSION.TTL);\n}\n\nexport function getCachedUserSession(userId: number): any | null {\n  const key = `${CacheSettings.USER_SESSION.PREFIX}:${userId}`;\n  return clientCache.get(key);\n}\n\n// Hook para usar caché en React\nexport function useClientCache() {\n  const setCache = (key: string, data: any, ttl?: number) => {\n    clientCache.set(key, data, ttl);\n  };\n\n  const getCache = (key: string) => {\n    return clientCache.get(key);\n  };\n\n  const hasCache = (key: string) => {\n    return clientCache.has(key);\n  };\n\n  const deleteCache = (key: string) => {\n    return clientCache.delete(key);\n  };\n\n  const clearCache = () => {\n    clientCache.clear();\n  };\n\n  const getStats = () => {\n    return clientCache.getStats();\n  };\n\n  return {\n    setCache,\n    getCache,\n    hasCache,\n    deleteCache,\n    clearCache,\n    getStats\n  };\n}"],"mappings":"AAAA;AACA;AACA;;AAcA,MAAMA,kBAAkB,CAAC;EAIvBC,WAAWA,CAACC,MAA4B,GAAG,CAAC,CAAC,EAAE;IAAA,KAHvCC,KAAK,GAA2B,IAAIC,GAAG,CAAC,CAAC;IAAA,KACzCF,MAAM;IAGZ,IAAI,CAACA,MAAM,GAAG;MACZG,UAAU,EAAE,CAAC,GAAG,EAAE,GAAG,IAAI;MAAE;MAC3BC,OAAO,EAAE,GAAG;MAAE;MACdC,UAAU,EAAE,WAAW;MACvB,GAAGL;IACL,CAAC;IAED,IAAI,CAACM,eAAe,CAAC,CAAC;IACtB,IAAI,CAACC,iBAAiB,CAAC,CAAC;EAC1B;;EAEA;AACF;AACA;EACEC,GAAGA,CAACC,GAAW,EAAEC,IAAS,EAAEC,GAAY,EAAQ;IAC9C,MAAMC,UAAU,GAAGD,GAAG,IAAI,IAAI,CAACX,MAAM,CAACG,UAAU;IAChD,MAAMU,IAAe,GAAG;MACtBH,IAAI;MACJI,SAAS,EAAEC,IAAI,CAACC,GAAG,CAAC,CAAC;MACrBL,GAAG,EAAEC;IACP,CAAC;;IAED;IACA,IAAI,IAAI,CAACX,KAAK,CAACgB,IAAI,IAAI,IAAI,CAACjB,MAAM,CAACI,OAAO,EAAE;MAC1C,IAAI,CAACc,WAAW,CAAC,CAAC;IACpB;IAEA,IAAI,CAACjB,KAAK,CAACO,GAAG,CAACC,GAAG,EAAEI,IAAI,CAAC;IACzB,IAAI,CAACM,aAAa,CAAC,CAAC;EACtB;;EAEA;AACF;AACA;EACEC,GAAGA,CAACX,GAAW,EAAc;IAC3B,MAAMI,IAAI,GAAG,IAAI,CAACZ,KAAK,CAACmB,GAAG,CAACX,GAAG,CAAC;IAEhC,IAAI,CAACI,IAAI,EAAE;MACT,OAAO,IAAI;IACb;;IAEA;IACA,IAAI,IAAI,CAACQ,SAAS,CAACR,IAAI,CAAC,EAAE;MACxB,IAAI,CAACZ,KAAK,CAACqB,MAAM,CAACb,GAAG,CAAC;MACtB,IAAI,CAACU,aAAa,CAAC,CAAC;MACpB,OAAO,IAAI;IACb;IAEA,OAAON,IAAI,CAACH,IAAI;EAClB;;EAEA;AACF;AACA;EACEa,GAAGA,CAACd,GAAW,EAAW;IACxB,MAAMI,IAAI,GAAG,IAAI,CAACZ,KAAK,CAACmB,GAAG,CAACX,GAAG,CAAC;IAChC,OAAOI,IAAI,GAAG,CAAC,IAAI,CAACQ,SAAS,CAACR,IAAI,CAAC,GAAG,KAAK;EAC7C;;EAEA;AACF;AACA;EACES,MAAMA,CAACb,GAAW,EAAW;IAC3B,MAAMe,MAAM,GAAG,IAAI,CAACvB,KAAK,CAACqB,MAAM,CAACb,GAAG,CAAC;IACrC,IAAIe,MAAM,EAAE;MACV,IAAI,CAACL,aAAa,CAAC,CAAC;IACtB;IACA,OAAOK,MAAM;EACf;;EAEA;AACF;AACA;EACEC,aAAaA,CAACC,OAAe,EAAU;IACrC,MAAMC,KAAK,GAAG,IAAIC,MAAM,CAACF,OAAO,CAAC;IACjC,IAAIG,YAAY,GAAG,CAAC;IAEpB,KAAK,MAAMpB,GAAG,IAAI,IAAI,CAACR,KAAK,CAAC6B,IAAI,CAAC,CAAC,EAAE;MACnC,IAAIH,KAAK,CAACI,IAAI,CAACtB,GAAG,CAAC,EAAE;QACnB,IAAI,CAACR,KAAK,CAACqB,MAAM,CAACb,GAAG,CAAC;QACtBoB,YAAY,EAAE;MAChB;IACF;IAEA,IAAIA,YAAY,GAAG,CAAC,EAAE;MACpB,IAAI,CAACV,aAAa,CAAC,CAAC;IACtB;IAEA,OAAOU,YAAY;EACrB;;EAEA;AACF;AACA;EACEG,KAAKA,CAAA,EAAS;IACZ,IAAI,CAAC/B,KAAK,CAAC+B,KAAK,CAAC,CAAC;IAClB,IAAI,CAACb,aAAa,CAAC,CAAC;EACtB;;EAEA;AACF;AACA;EACEc,QAAQA,CAAA,EAON;IACA;IACA,OAAO;MACLhB,IAAI,EAAE,IAAI,CAAChB,KAAK,CAACgB,IAAI;MACrBb,OAAO,EAAE,IAAI,CAACJ,MAAM,CAACI,OAAO;MAC5B8B,OAAO,EAAE,CAAC;MAAE;MACZC,aAAa,EAAE,CAAC;MAChBC,IAAI,EAAE,CAAC;MACPC,MAAM,EAAE;IACV,CAAC;EACH;;EAEA;AACF;AACA;EACUhB,SAASA,CAACR,IAAe,EAAW;IAC1C,OAAOE,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGH,IAAI,CAACC,SAAS,GAAGD,IAAI,CAACF,GAAG;EAC/C;;EAEA;AACF;AACA;EACUO,WAAWA,CAAA,EAAS;IAC1B,IAAIoB,SAAwB,GAAG,IAAI;IACnC,IAAIC,eAAe,GAAGxB,IAAI,CAACC,GAAG,CAAC,CAAC;IAEhC,KAAK,MAAM,CAACP,GAAG,EAAEI,IAAI,CAAC,IAAI,IAAI,CAACZ,KAAK,CAACuC,OAAO,CAAC,CAAC,EAAE;MAC9C,IAAI3B,IAAI,CAACC,SAAS,GAAGyB,eAAe,EAAE;QACpCA,eAAe,GAAG1B,IAAI,CAACC,SAAS;QAChCwB,SAAS,GAAG7B,GAAG;MACjB;IACF;IAEA,IAAI6B,SAAS,EAAE;MACb,IAAI,CAACrC,KAAK,CAACqB,MAAM,CAACgB,SAAS,CAAC;IAC9B;EACF;;EAEA;AACF;AACA;EACUG,OAAOA,CAAA,EAAS;IACtB,MAAMC,WAAqB,GAAG,EAAE;IAEhC,KAAK,MAAM,CAACjC,GAAG,EAAEI,IAAI,CAAC,IAAI,IAAI,CAACZ,KAAK,CAACuC,OAAO,CAAC,CAAC,EAAE;MAC9C,IAAI,IAAI,CAACnB,SAAS,CAACR,IAAI,CAAC,EAAE;QACxB6B,WAAW,CAACC,IAAI,CAAClC,GAAG,CAAC;MACvB;IACF;IAEA,IAAIiC,WAAW,CAACE,MAAM,GAAG,CAAC,EAAE;MAC1B,KAAK,MAAMnC,GAAG,IAAIiC,WAAW,EAAE;QAC7B,IAAI,CAACzC,KAAK,CAACqB,MAAM,CAACb,GAAG,CAAC;MACxB;MACA,IAAI,CAACU,aAAa,CAAC,CAAC;IACtB;EACF;;EAEA;AACF;AACA;EACUZ,iBAAiBA,CAAA,EAAS;IAChCsC,WAAW,CAAC,MAAM;MAChB,IAAI,CAACJ,OAAO,CAAC,CAAC;IAChB,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;EACb;;EAEA;AACF;AACA;EACUtB,aAAaA,CAAA,EAAS;IAC5B,IAAI;MACF,MAAM2B,eAAe,GAAGC,KAAK,CAACC,IAAI,CAAC,IAAI,CAAC/C,KAAK,CAACuC,OAAO,CAAC,CAAC,CAAC;MACxDS,YAAY,CAACC,OAAO,CAAC,IAAI,CAAClD,MAAM,CAACK,UAAU,EAAE8C,IAAI,CAACC,SAAS,CAACN,eAAe,CAAC,CAAC;IAC/E,CAAC,CAAC,OAAOO,KAAK,EAAE;MACdC,OAAO,CAACC,IAAI,CAAC,qCAAqC,EAAEF,KAAK,CAAC;IAC5D;EACF;;EAEA;AACF;AACA;EACU/C,eAAeA,CAAA,EAAS;IAC9B,IAAI;MACF,MAAMkD,MAAM,GAAGP,YAAY,CAACQ,OAAO,CAAC,IAAI,CAACzD,MAAM,CAACK,UAAU,CAAC;MAC3D,IAAImD,MAAM,EAAE;QACV,MAAME,MAAM,GAAGP,IAAI,CAACQ,KAAK,CAACH,MAAM,CAAC;QACjC,IAAI,CAACvD,KAAK,GAAG,IAAIC,GAAG,CAACwD,MAAM,CAAC;QAC5B;QACA,IAAI,CAACjB,OAAO,CAAC,CAAC;MAChB;IACF,CAAC,CAAC,OAAOY,KAAK,EAAE;MACdC,OAAO,CAACC,IAAI,CAAC,wCAAwC,EAAEF,KAAK,CAAC;MAC7D,IAAI,CAACpD,KAAK,CAAC+B,KAAK,CAAC,CAAC;IACpB;EACF;AACF;;AAEA;AACA,OAAO,MAAM4B,aAAa,GAAG;EAC3BC,QAAQ,EAAE;IACRC,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,IAAI;IAAE;IACpBC,MAAM,EAAE;EACV,CAAC;EACDC,cAAc,EAAE;IACdF,GAAG,EAAE,EAAE,GAAG,IAAI;IAAE;IAChBC,MAAM,EAAE;EACV,CAAC;EACDE,YAAY,EAAE;IACZH,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,IAAI;IAAE;IACrBC,MAAM,EAAE;EACV,CAAC;EACDG,WAAW,EAAE;IACXJ,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,IAAI;IAAE;IACrBC,MAAM,EAAE;EACV;AACF,CAAC;;AAED;AACA,OAAO,MAAMI,WAAW,GAAG,IAAIrE,kBAAkB,CAAC;EAChDK,UAAU,EAAE,CAAC,GAAG,EAAE,GAAG,IAAI;EACzBC,OAAO,EAAE,GAAG;EACZC,UAAU,EAAE;AACd,CAAC,CAAC;;AAEF;;AAEA,OAAO,SAAS+D,iBAAiBA,CAACC,QAAe,EAAEC,IAAY,GAAG,CAAC,EAAEC,KAAa,GAAG,EAAE,EAAQ;EAC7F,MAAM9D,GAAG,GAAG,GAAGmD,aAAa,CAACC,QAAQ,CAACE,MAAM,SAASO,IAAI,IAAIC,KAAK,EAAE;EACpEJ,WAAW,CAAC3D,GAAG,CAACC,GAAG,EAAE4D,QAAQ,EAAET,aAAa,CAACC,QAAQ,CAACC,GAAG,CAAC;AAC5D;AAEA,OAAO,SAASU,qBAAqBA,CAACF,IAAY,GAAG,CAAC,EAAEC,KAAa,GAAG,EAAE,EAAgB;EACxF,MAAM9D,GAAG,GAAG,GAAGmD,aAAa,CAACC,QAAQ,CAACE,MAAM,SAASO,IAAI,IAAIC,KAAK,EAAE;EACpE,OAAOJ,WAAW,CAAC/C,GAAG,CAACX,GAAG,CAAC;AAC7B;AAEA,OAAO,SAASgE,kBAAkBA,CAACC,KAAa,EAAEC,OAAc,EAAQ;EACtE,MAAMlE,GAAG,GAAG,GAAGmD,aAAa,CAACI,cAAc,CAACD,MAAM,IAAIW,KAAK,EAAE;EAC7DP,WAAW,CAAC3D,GAAG,CAACC,GAAG,EAAEkE,OAAO,EAAEf,aAAa,CAACI,cAAc,CAACF,GAAG,CAAC;AACjE;AAEA,OAAO,SAASc,sBAAsBA,CAACF,KAAa,EAAgB;EAClE,MAAMjE,GAAG,GAAG,GAAGmD,aAAa,CAACI,cAAc,CAACD,MAAM,IAAIW,KAAK,EAAE;EAC7D,OAAOP,WAAW,CAAC/C,GAAG,CAACX,GAAG,CAAC;AAC7B;AAEA,OAAO,SAASoE,uBAAuBA,CAAA,EAAS;EAC9CV,WAAW,CAAC1C,aAAa,CAAC,GAAGmC,aAAa,CAACC,QAAQ,CAACE,MAAM,KAAK,CAAC;EAChEI,WAAW,CAAC1C,aAAa,CAAC,GAAGmC,aAAa,CAACI,cAAc,CAACD,MAAM,KAAK,CAAC;AACxE;AAEA,OAAO,SAASe,gBAAgBA,CAACC,MAAc,EAAEC,WAAgB,EAAQ;EACvE,MAAMvE,GAAG,GAAG,GAAGmD,aAAa,CAACK,YAAY,CAACF,MAAM,IAAIgB,MAAM,EAAE;EAC5DZ,WAAW,CAAC3D,GAAG,CAACC,GAAG,EAAEuE,WAAW,EAAEpB,aAAa,CAACK,YAAY,CAACH,GAAG,CAAC;AACnE;AAEA,OAAO,SAASmB,oBAAoBA,CAACF,MAAc,EAAc;EAC/D,MAAMtE,GAAG,GAAG,GAAGmD,aAAa,CAACK,YAAY,CAACF,MAAM,IAAIgB,MAAM,EAAE;EAC5D,OAAOZ,WAAW,CAAC/C,GAAG,CAACX,GAAG,CAAC;AAC7B;;AAEA;AACA,OAAO,SAASyE,cAAcA,CAAA,EAAG;EAC/B,MAAMC,QAAQ,GAAGA,CAAC1E,GAAW,EAAEC,IAAS,EAAEC,GAAY,KAAK;IACzDwD,WAAW,CAAC3D,GAAG,CAACC,GAAG,EAAEC,IAAI,EAAEC,GAAG,CAAC;EACjC,CAAC;EAED,MAAMyE,QAAQ,GAAI3E,GAAW,IAAK;IAChC,OAAO0D,WAAW,CAAC/C,GAAG,CAACX,GAAG,CAAC;EAC7B,CAAC;EAED,MAAM4E,QAAQ,GAAI5E,GAAW,IAAK;IAChC,OAAO0D,WAAW,CAAC5C,GAAG,CAACd,GAAG,CAAC;EAC7B,CAAC;EAED,MAAM6E,WAAW,GAAI7E,GAAW,IAAK;IACnC,OAAO0D,WAAW,CAAC7C,MAAM,CAACb,GAAG,CAAC;EAChC,CAAC;EAED,MAAM8E,UAAU,GAAGA,CAAA,KAAM;IACvBpB,WAAW,CAACnC,KAAK,CAAC,CAAC;EACrB,CAAC;EAED,MAAMC,QAAQ,GAAGA,CAAA,KAAM;IACrB,OAAOkC,WAAW,CAAClC,QAAQ,CAAC,CAAC;EAC/B,CAAC;EAED,OAAO;IACLkD,QAAQ;IACRC,QAAQ;IACRC,QAAQ;IACRC,WAAW;IACXC,UAAU;IACVtD;EACF,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}